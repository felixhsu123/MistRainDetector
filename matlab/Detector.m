classdef Detector < handle
    %DETECTOR Summary of this class goes here
    %   Detailed explanation goes here
    
    properties (Constant, Access=private)
        FILTER_THRESHHOLD = 0.69;

        CONFIDENCE_MAX = 2;
        CONFIDENCE_MIN = -2;

        RAINING_MAX = .8;
        RAINING_MIN = -0.4;

        fft_sz = 4096;
       
        HpFilt = Detector.BuildHP;
        BpFilt = Detector.BuildBP;
        LpFilt = Detector.BuildLP;
    end
    
    properties (Access = private)
        golden = 0;
        last_intensity = 0;
        confidence = 0;
        cycle_num = 0;
    end
    
    
    methods (Access=private, Static)
        function Hd = BuildHP
            %BUILDHP Returns a discrete-time filter object.

            % MATLAB Code
            % Generated by MATLAB(R) 8.1 and the DSP System Toolbox 8.4.
            % Generated on: 04-May-2013 19:28:51

            % IIR Least P-th norm Highpass filter designed using the IIRLPNORM
            % function.

            % All frequency values are in Hz.
            Fs = 44100;  % Sampling Frequency

            Nb    = 12;       % Numerator Order
            Na    = 12;       % Denominator Order
            Fstop = 500;      % Stopband Frequency
            Fpass = 800;      % Passband Frequency
            Wstop = 1;        % Stopband Weight5
            Wpass = 1;        % Passband Weight
            P     = [2 128];  % P'th norm
            dens  = 20;       % Density Factor

            F = [0 Fstop Fpass Fs/2]/(Fs/2);

            % Calculate the coefficients using the IIRLPNORM function.
            [~,~,~,sos_var,g] = iirlpnorm(Nb, Na, F, F, [0 0 1 1], [Wstop Wstop ...
                                            Wpass Wpass], P, {dens});
            Hd                  = dfilt.df2sos(sos_var, g);
        end
        
        function Hd = BuildBP
            %BUILDBP Returns a discrete-time filter object.

            % MATLAB Code
            % Generated by MATLAB(R) 8.1 and the DSP System Toolbox 8.4.
            % Generated on: 04-May-2013 22:59:27

            % IIR Least P-th norm Bandpass filter designed using the IIRLPNORM
            % function.

            % All frequency values are in Hz.
            Fs = 44100;  % Sampling Frequency

            Nb     = 16;                  % Numerator Order
            Na     = 16;                  % Denominator Order
            Fstop1 = 500;                 % First Stopband Frequency
            Fpass1 = 900;  % First Passband Frequency
            Fpass2 = 15000;               % Second Passband Frequency
            Fstop2 = 22049;               % Second Stopband Frequency
            Wstop1 = 1;                   % First Stopband Weight
            Wpass  = 1;                   % Passband Weight
            Wstop2 = 1;                   % Second Stopband Weight
            P      = [2 128];             % P'th norm
            dens   = 20;                  % Density Factor

            F = [0 Fstop1 Fpass1 Fpass2 Fstop2 Fs/2]/(Fs/2);

            % Calculate the coefficients using the IIRLPNORM function.
            [~,~,~,sos_var,g] = iirlpnorm(Nb, Na, F, F, [0 0 1 1 0 0], [Wstop1 ...
                                            Wstop1 Wpass Wpass Wstop2 Wstop2], P, ...
                                            {dens});
            Hd                  = dfilt.df2sos(sos_var, g);
        end
        
        function Hd = BuildLP
            %BUILDLP Returns a discrete-time filter object.

            % MATLAB Code
            % Generated by MATLAB(R) 8.1 and the DSP System Toolbox 8.4.
            % Generated on: 04-May-2013 23:06:18

            % Chebyshev Type II Lowpass filter designed using FDESIGN.LOWPASS.

            % All frequency values are in Hz.
            Fs = 44100;  % Sampling Frequency

            Fpass = 18000;       % Passband Frequency
            Fstop = 20000;       % Stopband Frequency
            Apass = 0.5;           % Passband Ripple (dB)
            Astop = 80;          % Stopband Attenuation (dB)
            match = 'passband';  % Band to match exactly

            % Construct an FDESIGN object and call its CHEBY2 method.
            h  = fdesign.lowpass(Fpass, Fstop, Apass, Astop, Fs);
            Hd = design(h, 'cheby2', 'MatchExactly', match);

        end
    end
    
    methods (Access = public)
        function [this] = Detector()
            this.Reset();

            rrain1 = audioread('./data/rrain1.wav');
            start = 1;
            this.golden = this.MyFilter(rrain1(start:(start-1+this.fft_sz)));
        end
        
        function [l] = ChunkLength(this)
            l=this.fft_sz;
        end
        
        function [] = Reset(this)
        	this.confidence = 0;
            this.last_intensity = 0;
            this.cycle_num = 0;
        end
        
        function [intensities] = DoDetection(this, signal)
            pad = this.fft_sz - mod(size(signal,1), this.fft_sz);
            signal = cat(1, signal, zeros(pad, 1));
            
            signal = reshape(signal, this.fft_sz, size(signal,1)/this.fft_sz);
            
            intensities = zeros(size(signal,2),1);
            for i = 1:size(signal,2)
                intensities(i) = this.Detect(signal(:,i));
            end
        end
        
        function [intensity] = Detect(this, signal_chunk)
            %Detect Do rain detection operation on a single chunk
            
           if (size(signal_chunk,1) ~= this.fft_sz)
                error('Signal chunk size should be %d.', this.fft_sz);
           end
           
           intensity=this.DetectInternal(signal_chunk);
        end
    end
    
    
    methods (Access = public)
        function [intensity] = DetectInternal(this, signal_chunk)
            filtered = this.MyFilter(signal_chunk);
            
            corVal = corr(this.golden, filtered);
            
            diffVal = abs(corVal) - this.FILTER_THRESHHOLD;
            diffSign = sign(diffVal);      
            difMag = abs(diffVal);
            
            this.confidence = this.confidence+ diffSign*difMag;
            
            %fprintf(1, 'Confidence=%g\n', this.confidence);
            
            if (this.confidence > this.RAINING_MAX)
                intensity = 1;
                if (this.confidence > this.CONFIDENCE_MAX)
                    this.confidence = this.CONFIDENCE_MAX;
                end
            elseif (this.confidence < this.RAINING_MIN)
                intensity = 0;
                
                %fprintf(1, 'NO RAIN AT CYCLE %d\n', this.cycle_num);
                if (this.confidence < this.CONFIDENCE_MIN)
                    this.confidence = this.CONFIDENCE_MIN;
                end
            else
                intensity = this.last_intensity;
                return;
            end
            
            this.cycle_num = this.cycle_num + 1;
            this.last_intensity = intensity;
        end
        
        function [ filtered ] = MyFilter(this, signal_chunk)
            %MYFILTER Summary of this function goes here
            %   Detailed explanation goes here
            GoldFilt = dfilt.cascade(this.LpFilt, this.HpFilt);
            smooth_sz = 4;
            window_sz = 8;

            filtered = abs(fft(GoldFilt.filter(signal_chunk), this.fft_sz));
            filtered = filter(hamming(smooth_sz), 1, filtered);
            filtered = BlockMean(filtered, window_sz, 1);      
        end
    
    end
    
end

